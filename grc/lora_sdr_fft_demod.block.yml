# auto-generated by grc.converter

id: lora_sdr_fft_demod
label: fft_demod
category: '[LoRa_RX]'
flags: [python, cpp]

parameters:
-   id: soft_decoding
    label: Soft_Decoding
    dtype: bool
    default: 'soft_decoding'
    options: [False, True]
-   id: max_log_approx
    label: Max Log approx
    dtype: enum
    default: True
    options: ['False', 'True']
    option_labels: ['No', 'Yes']
    hide: ${ 'all' if not soft_decoding else 'part' }
-   id: legacy_sf56
    label: legacy_sf56
    dtype: bool
    hide: part
    default: False
    options: [False, True]

inputs:
-   domain: stream
    dtype: complex

outputs:
-   domain: stream
    dtype: ${ 'f64' if soft_decoding else 'short'}
    vlen: ${ 12 if soft_decoding else 1} #maximum bit per symbol is 12

templates:
    imports: import gnuradio.lora_sdr as lora_sdr
    make: lora_sdr.fft_demod( ${soft_decoding}, ${max_log_approx}, ${legacy_sf56})

cpp_templates: 
  includes: ['#include <gnuradio/lora_sdr/fft_demod.h>'] 
  declarations: 'lora_sdr::fft_demod::sptr ${id};' 
  make: 'this->${id} = lora_sdr::fft_demod::make(${soft_decoding}, ${max_log_approx}, ${legacy_sf56});'
  packages: ['gnuradio-lora_sdr']
  link: ['gnuradio::gnuradio-lora_sdr']
  translations:
     'False': 'false'
     'True': 'true'
     \[: '{'
     \]: '}'

documentation: |-
    Recover the value of a lora symbol using argmax(DFT(lora_symbol * ref_downchirp)
        Parameters: 
           impl_head: usage of an implicit header (explicit will be used otherwise) 
           soft_decoding: use soft-decision decoding, outputing LLRs instead of the argmax  
           legacy_sf56: Use legacy SF5/6 encoding  used by sx127x generation of chips 
        Input:        
            in: vector of 2^sf complex samples        
        Output:        
            out: stream of lora symbol decimal values or bits LLRs if soft-decision decoding is selected

file_format: 1
